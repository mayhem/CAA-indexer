#!/usr/bin/env perl

use strict;
use warnings;

use DBIx::Simple;
use Getopt::Long;
use JSON::Any;
use Pod::Usage;
use Try::Tiny;

my $verbose = 0;
my $db_name = 'musicbrainz';
my $db_user = 'musicbrainz';
my $opt_help;

GetOptions ("user=s" => \$db_user,
            "db=s"   => \$db_name,
            "verbose"  => \$verbose,
            "help|?" => \$opt_help)
    or pod2usage();
pod2usage(-verbose => 2) if $opt_help;

my $dbh = DBIx::Simple->connect("dbi:Pg:dbname=$db_name", $db_user);
my $json = JSON::Any->new( utf8 => 1 );

sub log_info (&) {
    return unless $verbose;
    my ($fmt, @args) = shift->();
    printf STDERR "%s INFO $fmt\n", scalar(localtime), @args;
}

sub log_error (&) {
    my ($fmt, @args) = shift->();
    printf STDERR "%s ERROR $fmt\n", scalar(localtime), @args;
}

sub index_release {
    my ($release_gid) = @_;

    my $release = $dbh->query(
        'SELECT name.name, release.barcode, ac_name.name artist, release.gid, release.id
         FROM musicbrainz.release
         JOIN musicbrainz.release_name name ON name.id = release.name
         JOIN musicbrainz.artist_credit ON artist_credit.id = release.artist_credit
         JOIN musicbrainz.artist_name ac_name ON ac_name.id = artist_credit.name
         WHERE release.id IN (
             SELECT new_id FROM musicbrainz.release_gid_redirect
             WHERE gid = ?
             UNION
             SELECT id FROM musicbrainz.release
             WHERE gid = ?
         )',
        $release_gid, $release_gid
    )->hash;

    # There are 3 possibilities
    # 1. The release has been changed, we only need to reindex
    if ($release && $release->{gid} eq $release_gid) {
        my $json = $json->objToJson({
            images => [
                map +{
                    types => [
                        $dbh->query(
                            'SELECT art_type.name
                             FROM cover_art_archive.cover_art_type
                             JOIN cover_art_archive.art_type ON cover_art_type.type_id = art_type.id
                             WHERE cover_art_type.id = ?',
                            $_->{id})->flat
                    ],
                    front => $_->{is_front} ? 'true' : 'false',
                    back => $_->{is_back} ? 'true' : 'false',
                    comment => $_->{comment},
                    image => $_->{url},
                    thumbnails => {
                        small => thumbnail_url($_->{url}, 250),
                        large => thumbnail_url($_->{url}, 500),
                    },
                    approved => $_->{approved} ? 'true' : 'false',
                    edit => $_->{edit}
                }, $dbh->query(
                    'SELECT *,
                       (release.front_image = cover_art.id) AS is_front,
                       (release.back_image = cover_art.id) AS is_back,
                       (edit.close_time IS NOT NULL) AS approved
                     FROM cover_art_archive.cover_art
                     JOIN cover_art_archive.release ON release.release = cover_art.release
                     JOIN musicbrainz.edit ON edit.id = cover_art.edit
                     WHERE cover_art.release = ?
                     ORDER BY ordering',
                    $release->{id}
                )->hashes
            ],
            release => {
                title => $release->{name},
                artist => $release->{artist},
                barcode => $release->{barcode},
                catalognumbers => [
                    $dbh->query(
                        'SELECT DISTINCT catalog_number
                         FROM musicbrainz.release_label
                         WHERE catalog_number IS NOT NULL AND release = ?',
                        $release->{id})->flat
                    ]
            }
        });

        log_info { "Produced %s", $json };
    }
    # 2. The release has been merged into another release.
    elsif ($release && $release->{gid} ne $release_gid) {
        die "Merges are not yet supported";
    }
    # 3. The release has been entirely deleted, so everything should be removed
    else {
        die "Deleting releases is not yet supported";
    }
}

while(1) {
    if (my $batch_id = $dbh->query('SELECT pgq.next_batch(?, ?)', 'CoverArtIndex', 'CoverArtIndexer')->list) {
        my @events = $dbh->query('SELECT * FROM pgq.get_batch_events(?)', $batch_id)->hashes;
        log_info { "Refreshing %d releases", scalar(@events) };

        for my $event (@events) {
            if ($event->{ev_type} ne 'index') {
                log_error { "Encountered an event that was not of ev_type 'index'. Marking as failed" };
                $dbh->query('SELECT pgq.event_failed(?, ?, ?)', $batch_id, $event->{ev_id}, 'Unknown ev_type');
                next;
            }

            try {
                index_release($event->{ev_data});
            }
            catch {
                log_error { "%s", $_ };
                $dbh->query('SELECT pgq.event_failed(?, ?, ?)', $batch_id, $event->{ev_id}, $_);
            };
        }

        $dbh->query('SELECT pgq.finish_batch(?)', $batch_id);
    }
    else {
        log_info { "Nothing to do" };
        sleep(10);
    }
}

sub thumbnail_url {
    my ($url, $size) = @_;
    $url =~ s/^(.*)\.([^\.]+)$/$1-$size.$2/;
    return $url;
}

__END__

=head1 NAME

caa-indexer

=head1 OPTIONS

=over 4

=item verbose

Run in verbose mode, showing detailed logging.

=item db

The name of the database to connect to poll for Cover Art Archive events.

=item user

The user name to use when connecting to the database.

=back

=head1 DESCRIPTION

The main database has a queue that holds events about releases that have cover
art. If a release that has cover art is in some way updated, such as the name
changing, an event is produced. This project is a consumer of that queue, and
runs as a daemon. When it receieves events, it looks up the information
necessary to produce an index file, and sticks it on the Internet Archive's
backend servers.

=cut
