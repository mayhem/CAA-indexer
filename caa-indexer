#!/usr/bin/env perl

use strict;
use warnings;

use DBIx::Simple;
use Getopt::Long;
use JSON::Any;
use Pod::Usage;
use Try::Tiny;

my $verbose = 0;
my $db_name = 'musicbrainz';
my $db_user = 'musicbrainz';
my $opt_help;

GetOptions ("user=s" => \$db_user,
            "db=s"   => \$db_name,
            "verbose"  => \$verbose,
            "help|?" => \$opt_help)
    or pod2usage();
pod2usage(-verbose => 2) if $opt_help;

my $dbh = DBIx::Simple->connect('dbi:Pg:dbname=musicbrainz', 'musicbrainz');
my $json = JSON::Any->new( utf8 => 1 );

sub log_info (&) {
    return unless $verbose;
    my ($fmt, @args) = shift->();
    printf STDERR "%s INFO $fmt\n", scalar(localtime), @args;
}

sub log_error (&) {
    my ($fmt, @args) = shift->();
    printf STDERR "%s ERROR $fmt\n", scalar(localtime), @args;
}

while(1) {
    if (my $batch_id = $dbh->query('SELECT pgq.next_batch(?, ?)', 'CoverArtIndex', 'CoverArtIndexer')->list) {
        my @events = $dbh->query('SELECT * FROM pgq.get_batch_events(?)', $batch_id)->hashes;
        log_info { "Refreshing %d releases", scalar(@events) };

        for my $event (@events) {
            if ($event->{ev_type} ne 'index') {
                log_error { "Encountered an event that was not of ev_type 'index'. Marking as failed" };
                $dbh->query('SELECT pgq.event_failed(?, ?, ?)', $batch_id, $event->{ev_id}, 'Unknown ev_type');
                next;
            }

            try {
                my $release_id = $event->{ev_data};

                my $release = $dbh->query(
                    'SELECT name.name, release.barcode, ac_name.name artist
                     FROM musicbrainz.release
                     JOIN musicbrainz.release_name name ON name.id = release.name
                     JOIN musicbrainz.artist_credit ON artist_credit.id = release.artist_credit
                     JOIN musicbrainz.artist_name ac_name ON ac_name.id = artist_credit.name
                     WHERE release.id = ?',
                    $release_id
                )->hash;

                my $json = $json->objToJson({
                    release => {
                        title => $release->{name},
                        artist => $release->{artist},
                        barcode => $release->{barcode},
                        catalognumbers => [
                            $dbh->query(
                                'SELECT DISTINCT catalog_number
                                 FROM musicbrainz.release_label
                                 WHERE catalog_number IS NOT NULL AND release = ?',
                                $release_id)->flat
                        ]
                    }
                });

                log_info { "Produced %s", $json };
            }
            catch {
                log_error { "ERROR: %s", $_ };
                $dbh->query('SELECT pgq.event_failed(?, ?, ?)', $batch_id, $event->{ev_id}, $_);
            };
        }

        $dbh->query('SELECT pgq.finish_batch(?)', $batch_id);
    }
    else {
        log_info { "Nothing to do" };
        sleep(10);
    }
}

__END__

=head1 NAME

caa-indexer

=head1 OPTIONS

=over 4

=item verbose

Run in verbose mode, showing detailed logging.

=item db

The name of the database to connect to poll for Cover Art Archive events.

=item user

The user name to use when connecting to the database.

=back

=head1 DESCRIPTION

The main database has a queue that holds events about releases that have cover
art. If a release that has cover art is in some way updated, such as the name
changing, an event is produced. This project is a consumer of that queue, and
runs as a daemon. When it receieves events, it looks up the information
necessary to produce an index file, and sticks it on the Internet Archive's
backend servers.

=cut
